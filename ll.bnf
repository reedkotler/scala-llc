// // Grammar from https://github.com/llir/grammar

/ ### [ Lexical part ] ########################################################

_ascii_letter
	: 'A' - 'Z'
	| 'a' - 'z'
;

_letter
	: _ascii_letter
	| '$'
	| '-'
	| '.'
	| '_'
;

_escape_letter
	: _letter
	| '\\'
;

_decimal_digit
	: '0' - '9'
;

_hex_digit
	: _decimal_digit
	| 'A' - 'F'
	| 'a' - 'f'
;

!comment : ';' { . } '\n' ;

!whitespace : '\x00' | ' ' | '\t' | '\r' | '\n' ;

// === [ Identifiers ] =========================================================

_name
	: _letter { _letter | _decimal_digit }
;

_escape_name
	: _escape_letter { _escape_letter | _decimal_digit }
;

_quoted_name
	: _quoted_string
;

_id
	: _decimals
;

// --- [ Global identifiers ] --------------------------------------------------

global_ident
	: _global_name
	| _global_id
;

_global_name
	: '@' ( _name | _quoted_name )
;

_global_id
	: '@' _id
;

// --- [ Local identifiers ] ---------------------------------------------------

local_ident
	: _local_name
	| _local_id
;

_local_name
	: '%' ( _name | _quoted_name )
;

_local_id
	: '%' _id
;

// --- [ Labels ] --------------------------------------------------------------

//   Label             [-a-zA-Z$._0-9]+:

label_ident
	: ( _letter | _decimal_digit ) { _letter | _decimal_digit } ':'
	| _quoted_string ':'
;

// --- [ Attribute group identifiers ] -----------------------------------------

attr_group_id
	: '#' _id
;

// --- [ Comdat identifiers ] --------------------------------------------------

comdat_name
	: '$' ( _name | _quoted_name )
;

// --- [ Metadata identifiers ] ------------------------------------------------

metadata_name
	: '!' _escape_name
;

metadata_id
	: '!' _id
;

// === [ Integer literals ] ====================================================

//   Integer           [-]?[0-9]+

int_lit
	: _decimal_lit
;

_decimal_lit
	: [ '-' ] _decimals
;

_decimals
	: _decimal_digit { _decimal_digit }
;

// === [ Floating-point literals ] =============================================

//   FPConstant        [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?

float_lit
	: _frac_lit
	| _sci_lit
	| _float_hex_lit
;

_frac_lit
	: [ _sign ] _decimals '.' { _decimal_digit }
;

_sign
	: '+'
	| '-'
;

_sci_lit
	: _frac_lit ( 'e' | 'E' ) [ _sign ] _decimals
;

//   HexFPConstant     0x[0-9A-Fa-f]+     // 16 hex digits
//   HexFP80Constant   0xK[0-9A-Fa-f]+    // 20 hex digits
//   HexFP128Constant  0xL[0-9A-Fa-f]+    // 32 hex digits
//   HexPPC128Constant 0xM[0-9A-Fa-f]+    // 32 hex digits
//   HexHalfConstant   0xH[0-9A-Fa-f]+    // 4 hex digits

_float_hex_lit
	:  '0' 'x'      _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit
	|  '0' 'x' 'K'  _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit
	|  '0' 'x' 'L'  _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit
	|  '0' 'x' 'M'  _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit _hex_digit
	|  '0' 'x' 'H'  _hex_digit _hex_digit _hex_digit _hex_digit
;

// === [ String literals ] =====================================================

string_lit
	: _quoted_string
;

_quoted_string
	: '"' { . } '"'
;

// === [ Types ] ===============================================================

int_type
	: 'i' _decimals
;

// ### [ Syntactic part ] ######################################################

<< import (
   "github.com/llir/llvm/asm/internal/ast"
   "github.com/llir/llvm/asm/internal/astx"
) >>

// === [ Modules ] =============================================================

Module
	: TopLevelDecls   << astx.NewModule($0) >>
;

TopLevelDecls
	: empty
	| TopLevelDeclList
;

TopLevelDeclList
	: TopLevelDecl                    << astx.NewTopLevelDeclList($0) >>
	| TopLevelDeclList TopLevelDecl   << astx.AppendTopLevelDecl($0, $1) >>
;

TopLevelDecl
	: SourceFilename
	| TargetSpec
	| ModuleAsm
	| TypeDef
	| ComdatDef
	| GlobalDecl
	| GlobalDef
	| FuncDecl
	| FuncDef
	| AttrGroupDef
	| NamedMetadataDef
	| MetadataDef
;

// --- [ Source filename ] -----------------------------------------------------

SourceFilename
	: "source_filename" "=" string_lit   << nil, nil >>
;

// --- [ Target specifiers ] ---------------------------------------------------

TargetSpec
	: "target" DataLayout     << $1, nil >>
	| "target" TargetTriple   << $1, nil >>
;

DataLayout
	: "datalayout" "=" string_lit   << astx.NewDataLayout($2) >>
;

TargetTriple
	: "triple" "=" string_lit   << astx.NewTargetTriple($2) >>
;

// --- [ Module-level inline assembly ] ----------------------------------------

// ref: http://llvm.org/docs/LangRef.html#module-level-inline-assembly
ModuleAsm
	: "module" "asm" string_lit   << nil, nil >>
;

// --- [ Type definitions ] ----------------------------------------------------

TypeDef
	: LocalIdent "=" "type" Type       << astx.NewTypeDef($0, $3) >>
	| LocalIdent "=" "type" "opaque"   << astx.NewTypeDefOpaque($0) >>
;

// --- [ Comdat definitions ] --------------------------------------------------

ComdatDef
	: ComdatName "=" "comdat" SelectionKind   << nil, nil >>
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#comdats
SelectionKind
	: "any"
	| "exactmatch"
	| "largest"
	| "noduplicates"
	| "samesize"
;

// --- [ Global variables ] ----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDecl
//       : GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDecl($0, $3, $4, $5, $9) >>
//    ;
GlobalDecl
	: GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType OptCommaAttachedMDList                                    << astx.NewGlobalDecl($0, $3, $4, $5, $6) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Align OptCommaAttachedMDList                          << astx.NewGlobalDecl($0, $3, $4, $5, $8) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Comdat OptCommaAttachedMDList                         << astx.NewGlobalDecl($0, $3, $4, $5, $8) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Comdat "," Align OptCommaAttachedMDList               << astx.NewGlobalDecl($0, $3, $4, $5, $10) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Section OptCommaAttachedMDList                        << astx.NewGlobalDecl($0, $3, $4, $5, $8) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Section "," Align OptCommaAttachedMDList              << astx.NewGlobalDecl($0, $3, $4, $5, $10) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Section "," Comdat OptCommaAttachedMDList             << astx.NewGlobalDecl($0, $3, $4, $5, $10) >>
	| GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType "," Section "," Comdat "," Align OptCommaAttachedMDList   << astx.NewGlobalDecl($0, $3, $4, $5, $12) >>
;

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDef
//       : GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDef($0, $3, $4, $5, $6, $10) >>
//    ;
GlobalDef
	: GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant OptCommaAttachedMDList                                    << astx.NewGlobalDef($0, $3, $4, $5, $6, $7) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Align OptCommaAttachedMDList                          << astx.NewGlobalDef($0, $3, $4, $5, $6, $9) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Comdat OptCommaAttachedMDList                         << astx.NewGlobalDef($0, $3, $4, $5, $6, $9) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Comdat "," Align OptCommaAttachedMDList               << astx.NewGlobalDef($0, $3, $4, $5, $6, $11) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Section OptCommaAttachedMDList                        << astx.NewGlobalDef($0, $3, $4, $5, $6, $9) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Section "," Align OptCommaAttachedMDList              << astx.NewGlobalDef($0, $3, $4, $5, $6, $11) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Section "," Comdat OptCommaAttachedMDList             << astx.NewGlobalDef($0, $3, $4, $5, $6, $11) >>
	| GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant "," Section "," Comdat "," Align OptCommaAttachedMDList   << astx.NewGlobalDef($0, $3, $4, $5, $6, $13) >>
;

GlobalOptions
	: OptVisibility OptDLLStorageClass OptThreadLocal OptUnnamedAddr OptAddrSpace OptExternallyInitialized   << $4, nil >>
;

OptExternallyInitialized
	: empty
	| ExternallyInitialized
;

ExternallyInitialized
	: "externally_initialized"
;

Immutable
	: "constant"   << true, nil >>
	| "global"     << false, nil >>
;

// --- [ Functions ] -----------------------------------------------------------

FuncDecl
	: "declare" AttachedMDs OptExternLinkage FuncHeader   << astx.NewFuncDecl($1, $3) >>
;

FuncDef
	: "define" OptLinkage FuncHeader AttachedMDs FuncBody   << astx.NewFuncDef($2, $3, $4) >>
;

FuncHeader
	: OptVisibility OptDLLStorageClass OptCallConv ParamAttrs Type GlobalIdent
	  "(" Params ")" OptUnnamedAddr FuncAttrs OptSection OptComdat OptAlign
	      OptGC OptPrefix OptPrologue OptPersonality   << astx.NewFuncHeader($2, $4, $5, $7) >>
;

Params
	: empty
	| "..."                 << astx.NewParams(nil, true) >>
	| ParamList             << astx.NewParams($0, false) >>
	| ParamList "," "..."   << astx.NewParams($0, true) >>
;

ParamList
	: Param                 << astx.NewParamList($0) >>
	| ParamList "," Param   << astx.AppendParam($0, $2) >>
;

Param
	: FirstClassType ParamAttrs              << astx.NewParam($0, nil) >>
	| FirstClassType ParamAttrs LocalIdent   << astx.NewParam($0, $2) >>
;

FuncBody
	: "{" BasicBlockList "}"   << $1, nil >>
;

// --- [ Attribute group definitions ] -----------------------------------------

AttrGroupDef
	: "attributes" AttrGroupID "=" "{" FuncAttrList "}"   << nil, nil >>
;

// --- [ Metadata definitions ] ------------------------------------------------

NamedMetadataDef
	: MetadataName "=" "!" "{" MetadataIDs "}"   << astx.NewNamedMetadataDef($0, $4) >>
;

MetadataIDs
	: empty
	| MetadataIDList
;

MetadataIDList
	: MetadataID                      << astx.NewMetadataIDList($0) >>
	| MetadataIDList "," MetadataID   << astx.AppendMetadataID($0, $2) >>
;

MetadataDef
	: MetadataID "=" OptDistinct Metadata   << astx.NewMetadataDef($0, $3) >>
;

OptDistinct
	: empty
	| "distinct"
;

Metadata
	: "!" "{" MetadataNodes "}"   << astx.NewMetadata($2) >>
;

MetadataNodes
	: empty
	| MetadataNodeList
;

MetadataNodeList
	: MetadataNode                        << astx.NewMetadataNodeList($0) >>
	| MetadataNodeList "," MetadataNode   << astx.AppendMetadataNode($0, $2) >>
;

MetadataNode
	: Metadata
	| MetadataID
	| "!" string_lit   << astx.NewMetadataString($1) >>
	| Type Constant    << astx.NewConstant($0, $1) >>
;

// === [ Identifiers ] =========================================================

GlobalIdent
	: global_ident   << astx.NewGlobalIdent($0) >>
;

LocalIdent
	: local_ident   << astx.NewLocalIdent($0) >>
;

LabelIdent
	: label_ident   << astx.NewLabelIdent($0) >>
;

AttrGroupID
	: attr_group_id
;

ComdatName
	: comdat_name
;

MetadataName
	: metadata_name   << astx.NewMetadataName($0) >>
;

MetadataID
	: metadata_id   << astx.NewMetadataID($0) >>
;

// === [ Types ] ===============================================================

Type
	: VoidType
	| FuncType
	| FirstClassType
;

FirstClassType
	: IntType
	| FloatType
	| PointerType
	| VectorType
	| LabelType
	| MetadataType
	| ArrayType
	| StructType
	| NamedType
;

// --- [ Void type ] -----------------------------------------------------------

VoidType
	: "void"   << &ast.VoidType{}, nil >>
;

// --- [ Function type ] -------------------------------------------------------

FuncType
	: Type "(" ParamTypes ")"   << astx.NewFuncType($0, $2) >>
;

ParamTypes
	: empty
	| "..."                     << astx.NewParams(nil, true) >>
	| ParamTypeList             << astx.NewParams($0, false) >>
	| ParamTypeList "," "..."   << astx.NewParams($0, true) >>
;

ParamTypeList
	: ParamType                     << astx.NewParamList($0) >>
	| ParamTypeList "," ParamType   << astx.AppendParam($0, $2) >>
;

ParamType
	: FirstClassType   << astx.NewParam($0, nil) >>
;

// --- [ Integer type ] --------------------------------------------------------

IntType
	: int_type   << astx.NewIntType($0) >>
;

// --- [ Floating-point type ] -------------------------------------------------

FloatType
	: "half"        << &ast.FloatType{Kind: ast.FloatKindIEEE_16}, nil >>
	| "float"       << &ast.FloatType{Kind: ast.FloatKindIEEE_32}, nil >>
	| "double"      << &ast.FloatType{Kind: ast.FloatKindIEEE_64}, nil >>
	| "fp128"       << &ast.FloatType{Kind: ast.FloatKindIEEE_128}, nil >>
	| "x86_fp80"    << &ast.FloatType{Kind: ast.FloatKindDoubleExtended_80}, nil >>
	| "ppc_fp128"   << &ast.FloatType{Kind: ast.FloatKindDoubleDouble_128}, nil >>
;

// --- [ Pointer type ] --------------------------------------------------------

PointerType
	: Type OptAddrSpace "*"   << astx.NewPointerType($0, $1) >>
;

OptAddrSpace
	: empty
	| "addrspace" "(" IntLit ")"   << $2, nil >>
;

// --- [ Vector type ] ---------------------------------------------------------

VectorType
	: "<" IntLit "x" FirstClassType ">"   << astx.NewVectorType($1, $3) >>
;

// --- [ Label type ] ----------------------------------------------------------

LabelType
	: "label"   << &ast.LabelType{}, nil >>
;

// --- [ Metadata type ] -------------------------------------------------------

MetadataType
	: "metadata"   << &ast.MetadataType{}, nil >>
;

// --- [ Array type ] ----------------------------------------------------------

ArrayType
	: "[" IntLit "x" FirstClassType "]"   << astx.NewArrayType($1, $3) >>
;

// --- [ struct type ] ---------------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructType
//       : "{" Fields "}"
//       | "<" "{" Fields "}" ">"
//    ;
//
//    Fields
//       : empty
//       | FieldList
//    ;
StructType
	: "{" "}"                     << astx.NewStructType(nil) >>
	| "{" FieldList "}"           << astx.NewStructType($1) >>
	| "<" "{" "}" ">"             << astx.NewStructType(nil) >>
	| "<" "{" FieldList "}" ">"   << astx.NewStructType($2) >>
;

FieldList
	: FirstClassType                 << astx.NewTypeList($0) >>
	| FieldList "," FirstClassType   << astx.AppendType($0, $2) >>
;

// --- [ Named type ] ----------------------------------------------------------

NamedType
	: LocalIdent   << astx.NewTypeIdent($0) >>
;

// === [ Values ] ==============================================================

Value
	: LocalIdent
	| Constant
;

// === [ Constants ] ===========================================================

Constant
	: IntConst
	| FloatConst
	| NullConst
	| VectorConst
	| ArrayConst
	| CharArrayConst
	| StructConst
	| ZeroInitializerConst
	| GlobalIdent
	| UndefConst
	| ConstExpr
;

// --- [ Integer constant ] ----------------------------------------------------

IntConst
	: IntLit
	| BoolLit
;

IntLit
	: int_lit   << astx.NewIntLit($0) >>
;

BoolLit
	: "true"    << astx.NewBoolLit($0) >>
	| "false"   << astx.NewBoolLit($0) >>
;

// --- [ Floating-point constant ] ---------------------------------------------

FloatConst
	: float_lit   << astx.NewFloatLit($0) >>
;

// --- [ Pointer constant ] ----------------------------------------------------

NullConst
	: "null"   << &astx.NullLit{}, nil >>
;

// --- [ Vector constant ] -----------------------------------------------------

VectorConst
	: "<" ElemList ">"   << astx.NewVectorConst($1) >>
;

// --- [ Array constant ] ------------------------------------------------------

ArrayConst
	: "[" Elems "]"   << astx.NewArrayConst($1) >>
;

CharArrayConst
	: "c" string_lit   << astx.NewCharArrayConst($1) >>
;

// --- [ Struct constant ] -----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructConst
//       : "{" Elems "}"
//       | "<" "{" Elems "}" ">"
//    ;
StructConst
	: "{" "}"                   << astx.NewStructConst(nil) >>
	| "{" ElemList "}"          << astx.NewStructConst($1) >>
	| "<" "{" "}" ">"           << astx.NewStructConst(nil) >>
	| "<" "{" ElemList "}" ">"  << astx.NewStructConst($2) >>
;

// --- [ Zero initializer constant ] -------------------------------------------

ZeroInitializerConst
	: "zeroinitializer"   << &astx.ZeroInitializerLit{}, nil >>
;

// --- [ Undefined value constant ] --------------------------------------------

UndefConst
	: "undef"   << &astx.UndefLit{}, nil >>
;

// === [ Constant expressions ] ================================================

ConstExpr
	// Binary expressions
	: AddExpr
	| FAddExpr
	| SubExpr
	| FSubExpr
	| MulExpr
	| FMulExpr
	| UDivExpr
	| SDivExpr
	| FDivExpr
	| URemExpr
	| SRemExpr
	| FRemExpr
	// Bitwise expressions
	| ShlExpr
	| LShrExpr
	| AShrExpr
	| AndExpr
	| OrExpr
	| XorExpr
	// Vector expressions
	| ExtractElementExpr
	| InsertElementExpr
	| ShuffleVectorExpr
	// Aggregate expressions
	| ExtractValueExpr
	| InsertValueExpr
	// Memory expressions
	| GetElementPtrExpr
	// Conversion expressions
	| TruncExpr
	| ZExtExpr
	| SExtExpr
	| FPTruncExpr
	| FPExtExpr
	| FPToUIExpr
	| FPToSIExpr
	| UIToFPExpr
	| SIToFPExpr
	| PtrToIntExpr
	| IntToPtrExpr
	| BitCastExpr
	| AddrSpaceCastExpr
	// Other expressions
	| ICmpExpr
	| FCmpExpr
	| SelectExpr
;

// --- [ Binary expressions ] --------------------------------------------------

AddExpr
	: "add" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewAddExpr($2, $3, $5, $6) >>
;

FAddExpr
	: "fadd" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewFAddExpr($2, $3, $5, $6) >>
;

SubExpr
	: "sub" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewSubExpr($2, $3, $5, $6) >>
;

FSubExpr
	: "fsub" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewFSubExpr($2, $3, $5, $6) >>
;

MulExpr
	: "mul" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewMulExpr($2, $3, $5, $6) >>
;

FMulExpr
	: "fmul" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewFMulExpr($2, $3, $5, $6) >>
;

UDivExpr
	: "udiv" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewUDivExpr($2, $3, $5, $6) >>
;

SDivExpr
	: "sdiv" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewSDivExpr($2, $3, $5, $6) >>
;

FDivExpr
	: "fdiv" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewFDivExpr($2, $3, $5, $6) >>
;

URemExpr
	: "urem" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewURemExpr($2, $3, $5, $6) >>
;

SRemExpr
	: "srem" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewSRemExpr($2, $3, $5, $6) >>
;

FRemExpr
	: "frem" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewFRemExpr($2, $3, $5, $6) >>
;

// --- [ Bitwise expressions ] -------------------------------------------------

ShlExpr
	: "shl" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewShlExpr($2, $3, $5, $6) >>
;

LShrExpr
	: "lshr" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewLShrExpr($2, $3, $5, $6) >>
;

AShrExpr
	: "ashr" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewAShrExpr($2, $3, $5, $6) >>
;

AndExpr
	: "and" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewAndExpr($2, $3, $5, $6) >>
;

OrExpr
	: "or" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewOrExpr($2, $3, $5, $6) >>
;

XorExpr
	: "xor" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewXorExpr($2, $3, $5, $6) >>
;

// --- [ Vector expressions ] --------------------------------------------------

ExtractElementExpr
	: "extractelement" "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewExtractElementExpr($2, $3, $5, $6) >>
;

InsertElementExpr
	: "insertelement" "(" FirstClassType Constant "," FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewInsertElementExpr($2, $3, $5, $6, $8, $9) >>
;

ShuffleVectorExpr
	: "shufflevector" "(" FirstClassType Constant "," FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewShuffleVectorExpr($2, $3, $5, $6, $8, $9) >>
;

// --- [ Aggregate expressions ] -----------------------------------------------

ExtractValueExpr
	: "extractvalue" "(" FirstClassType Constant "," IntLitList ")"   << astx.NewExtractValueExpr($2, $3, $5) >>
;

InsertValueExpr
	: "insertvalue" "(" FirstClassType Constant "," FirstClassType Constant "," IntLitList ")"   << astx.NewInsertValueExpr($2, $3, $5, $6, $8) >>
;

// --- [ Memory expressions ] --------------------------------------------------

GetElementPtrExpr
	: "getelementptr" OptInbounds "(" FirstClassType "," FirstClassType Constant ConstIndices ")"   << astx.NewGetElementPtrExpr($3, $5, $6, $7) >>
;

ConstIndices
	: empty
	| "," ConstIndexList   << $1, nil >>
;

ConstIndexList
	: ConstIndex                      << astx.NewConstantList($0) >>
	| ConstIndexList "," ConstIndex   << astx.AppendConstant($0, $2) >>
;

ConstIndex
	: IntType Constant   << astx.NewConstant($0, $1) >>
;

// --- [ Conversion expressions ] ----------------------------------------------

TruncExpr
	: "trunc" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewTruncExpr($2, $3, $5) >>
;

ZExtExpr
	: "zext" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewZExtExpr($2, $3, $5) >>
;

SExtExpr
	: "sext" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewSExtExpr($2, $3, $5) >>
;

FPTruncExpr
	: "fptrunc" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewFPTruncExpr($2, $3, $5) >>
;

FPExtExpr
	: "fpext" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewFPExtExpr($2, $3, $5) >>
;

FPToUIExpr
	: "fptoui" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewFPToUIExpr($2, $3, $5) >>
;

FPToSIExpr
	: "fptosi" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewFPToSIExpr($2, $3, $5) >>
;

UIToFPExpr
	: "uitofp" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewUIToFPExpr($2, $3, $5) >>
;

SIToFPExpr
	: "sitofp" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewSIToFPExpr($2, $3, $5) >>
;

PtrToIntExpr
	: "ptrtoint" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewPtrToIntExpr($2, $3, $5) >>
;

IntToPtrExpr
	: "inttoptr" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewIntToPtrExpr($2, $3, $5) >>
;

BitCastExpr
	: "bitcast" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewBitCastExpr($2, $3, $5) >>
;

AddrSpaceCastExpr
	: "addrspacecast" "(" FirstClassType Constant "to" FirstClassType ")"   << astx.NewAddrSpaceCastExpr($2, $3, $5) >>
;

// --- [ Other expressions ] ---------------------------------------------------

ICmpExpr
	: "icmp" IntPred "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewICmpExpr($1, $3, $4, $6, $7) >>
;

FCmpExpr
	: "fcmp" FloatPred "(" FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewFCmpExpr($1, $3, $4, $6, $7) >>
;

SelectExpr
	: "select" "(" FirstClassType Constant "," FirstClassType Constant "," FirstClassType Constant ")"   << astx.NewSelectExpr($2, $3, $5, $6, $8, $9) >>
;

// === [ Basic blocks ] ========================================================

BasicBlockList
	: BasicBlock                  << astx.NewBasicBlockList($0) >>
	| BasicBlockList BasicBlock   << astx.AppendBasicBlock($0, $1) >>
;

BasicBlock
	: OptLabelIdent Instructions Terminator   << astx.NewBasicBlock($0, $1, $2) >>
;

OptLabelIdent
	: empty
	| LabelIdent
;

// === [ Instructions ] ========================================================

Instructions
	: empty
	| InstructionList
;

InstructionList
	: Instruction                   << astx.NewInstructionList($0) >>
	| InstructionList Instruction   << astx.AppendInstruction($0, $1) >>
;

Instruction
	: StoreInst
	| FenceInst
	| CmpXchgInst
	| AtomicRMWInst
	| LocalIdent "=" ValueInstruction   << astx.NewNamedInstruction($0, $2) >>
	| ValueInstruction
;

ValueInstruction
	// Binary instructions
	: AddInst
	| FAddInst
	| SubInst
	| FSubInst
	| MulInst
	| FMulInst
	| UDivInst
	| SDivInst
	| FDivInst
	| URemInst
	| SRemInst
	| FRemInst
	// Bitwise instructions
	| ShlInst
	| LShrInst
	| AShrInst
	| AndInst
	| OrInst
	| XorInst
	// Vector instructions
	| ExtractElementInst
	| InsertElementInst
	| ShuffleVectorInst
	// Aggregate instructions
	| ExtractValueInst
	| InsertValueInst
	// Memory instructions
	| AllocaInst
	| LoadInst
	| GetElementPtrInst
	// Conversion instructions
	| TruncInst
	| ZExtInst
	| SExtInst
	| FPTruncInst
	| FPExtInst
	| FPToUIInst
	| FPToSIInst
	| UIToFPInst
	| SIToFPInst
	| PtrToIntInst
	| IntToPtrInst
	| BitCastInst
	| AddrSpaceCastInst
	// Other instructions
	| ICmpInst
	| FCmpInst
	| PhiInst
	| SelectInst
	| CallInst
	| VAArgInst
	| LandingPadInst
	| CatchPadInst
	| CleanupPadInst
;

// --- [ Binary instructions ] -------------------------------------------------

// ~~~ [ add ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AddInst
	: "add" OverflowFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewAddInst($2, $3, $5, $6) >>
;

// ~~~ [ fadd ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FAddInst
	: "fadd" FastMathFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewFAddInst($2, $3, $5, $6) >>
;

// ~~~ [ sub ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SubInst
	: "sub" OverflowFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewSubInst($2, $3, $5, $6) >>
;

// ~~~ [ fsub ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FSubInst
	: "fsub" FastMathFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewFSubInst($2, $3, $5, $6) >>
;

// ~~~ [ mul ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MulInst
	: "mul" OverflowFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewMulInst($2, $3, $5, $6) >>
;

// ~~~ [ fmul ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FMulInst
	: "fmul" FastMathFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewFMulInst($2, $3, $5, $6) >>
;

// ~~~ [ udiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UDivInst
	: "udiv" OptExact FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewUDivInst($2, $3, $5, $6) >>
;

// ~~~ [ sdiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SDivInst
	: "sdiv" OptExact FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewSDivInst($2, $3, $5, $6) >>
;

// ~~~ [ fdiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FDivInst
	: "fdiv" FastMathFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewFDivInst($2, $3, $5, $6) >>
;

// ~~~ [ urem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

URemInst
	: "urem" FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewURemInst($1, $2, $4, $5) >>
;

// ~~~ [ srem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SRemInst
	: "srem" FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewSRemInst($1, $2, $4, $5) >>
;

// ~~~ [ frem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FRemInst
	: "frem" FastMathFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewFRemInst($2, $3, $5, $6) >>
;

OverflowFlags
	: empty
	| OverflowFlagList
;

OverflowFlagList
	: OverflowFlag
	| OverflowFlagList OverflowFlag
;

OverflowFlag
	: "nuw"
	| "nsw"
;

FastMathFlags
	: empty
	| FastMathFlagList
;

FastMathFlagList
	: FastMathFlag
	| FastMathFlagList FastMathFlag
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#fast-math-flags
FastMathFlag
	: "arcp"
	| "fast"
	| "ninf"
	| "nnan"
	| "nsz"
;

OptExact
	: empty
	| "exact"
;

// --- [ Bitwise instructions ] ------------------------------------------------

// ~~~ [ shl ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ShlInst
	: "shl" OverflowFlags FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewShlInst($2, $3, $5, $6) >>
;

// ~~~ [ lshr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LShrInst
	: "lshr" OptExact FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewLShrInst($2, $3, $5, $6) >>
;

// ~~~ [ ashr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AShrInst
	: "ashr" OptExact FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewAShrInst($2, $3, $5, $6) >>
;

// ~~~ [ and ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AndInst
	: "and" FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewAndInst($1, $2, $4, $5) >>
;

// ~~~ [ or ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OrInst
	: "or" FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewOrInst($1, $2, $4, $5) >>
;

// ~~~ [ xor ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XorInst
	: "xor" FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewXorInst($1, $2, $4, $5) >>
;

// --- [ Vector instructions ] -------------------------------------------------

// ~~~ [ extractelement ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ExtractElementInst
	: "extractelement" FirstClassType Value "," FirstClassType Value OptCommaAttachedMDList   << astx.NewExtractElementInst($1, $2, $4, $5, $6) >>
;

// ~~~ [ insertelement ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InsertElementInst
	: "insertelement" FirstClassType Value "," FirstClassType Value "," FirstClassType Value OptCommaAttachedMDList   << astx.NewInsertElementInst($1, $2, $4, $5, $7, $8, $9) >>
;

// ~~~ [ shufflevector ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ShuffleVectorInst
	: "shufflevector" FirstClassType Value "," FirstClassType Value "," FirstClassType Value OptCommaAttachedMDList   << astx.NewShuffleVectorInst($1, $2, $4, $5, $7, $8, $9) >>
;

// --- [ Aggregate  instructions ] ---------------------------------------------

// ~~~ [ extractvalue ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ExtractValueInst
	: "extractvalue" FirstClassType Value "," IntLitList OptCommaAttachedMDList   << astx.NewExtractValueInst($1, $2, $4, $5) >>
;

IntLitList
	: IntLit                  << astx.NewIntLitList($0) >>
	| IntLitList "," IntLit   << astx.AppendIntLit($0, $2) >>
;

// ~~~ [ insertvalue ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InsertValueInst
	: "insertvalue" FirstClassType Value "," FirstClassType Value "," IntLitList OptCommaAttachedMDList   << astx.NewInsertValueInst($1, $2, $4, $5, $7, $8) >>
;

// --- [ Memory instructions ] -------------------------------------------------

// ~~~ [ alloca ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    AllocaInst
//       : "alloca" FirstClassType OptCommaNElems OptCommaAlign OptCommaAttachedMDList   << astx.NewAllocaInst($1, $2, $4) >>
//    ;
//
//    OptCommaNElems
//       : empty
//       | "," NElems   << $1 >>
//    ;
AllocaInst
	: "alloca" FirstClassType OptCommaAttachedMDList                        << astx.NewAllocaInst($1, nil, $2) >>
	| "alloca" FirstClassType "," Align OptCommaAttachedMDList              << astx.NewAllocaInst($1, nil, $4) >>
	| "alloca" FirstClassType "," NElems OptCommaAttachedMDList             << astx.NewAllocaInst($1, $3, $4) >>
	| "alloca" FirstClassType "," NElems "," Align OptCommaAttachedMDList   << astx.NewAllocaInst($1, $3, $6) >>
;

NElems
	: FirstClassType Value   << astx.NewValue($0, $1) >>
;

// ~~~ [ load ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    LoadInst
//       : "load" OptVolatile FirstClassType "," PointerType Value OptCommaAlign OptCommaAttachedMDList   << astx.NewLoadInst($2, $4, $5, $7) >>
//    ;
LoadInst
	: "load" OptVolatile FirstClassType "," PointerType Value OptCommaAttachedMDList             << astx.NewLoadInst($2, $4, $5, $6) >>
	| "load" OptVolatile FirstClassType "," PointerType Value "," Align OptCommaAttachedMDList   << astx.NewLoadInst($2, $4, $5, $8) >>
;

OptVolatile
	: empty
	| "volatile"
;

// ~~~ [ store ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StoreInst
//       : "store" OptVolatile FirstClassType Value "," PointerType Value OptCommaAlign OptCommaAttachedMDList   << astx.NewStoreInst($2, $3, $5, $6, $8) >>
//    ;
StoreInst
	: "store" OptVolatile FirstClassType Value "," PointerType Value OptCommaAttachedMDList             << astx.NewStoreInst($2, $3, $5, $6, $7) >>
	| "store" OptVolatile FirstClassType Value "," PointerType Value "," Align OptCommaAttachedMDList   << astx.NewStoreInst($2, $3, $5, $6, $9) >>
;

// ~~~ [ fence ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FenceInst
	: "fence" OptSinglethread Ordering OptCommaAttachedMDList   << nil, nil >>
;

OptSinglethread
	: empty
	| "singlethread"
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#ordering
Ordering
	: "acq_rel"
	| "acquire"
	| "monotonic"
	| "release"
	| "seq_cst"
	| "unordered"
;

// ~~~ [ cmpxchg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CmpXchgInst
	: "cmpxchg" OptWeak OptVolatile FirstClassType Value "," FirstClassType Value "," FirstClassType Value OptSinglethread Ordering Ordering OptCommaAttachedMDList   << nil, nil >>
;

OptWeak
	: empty
	| "weak"
;

// ~~~ [ atomicrmw ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AtomicRMWInst
	: "atomicrmw" OptVolatile AtomicOperation FirstClassType Value "," FirstClassType Value OptSinglethread Ordering OptCommaAttachedMDList   << nil, nil >>
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#atomicrmw-instruction
AtomicOperation
	: "add"
	| "and"
	| "max"
	| "min"
	| "nand"
	| "or"
	| "sub"
	| "umax"
	| "umin"
	| "xchg"
	| "xor"
;

// ~~~ [ getelementptr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//    GetElementPtrInst
//       : "getelementptr" OptInbounds FirstClassType "," FirstClassType Value Indices OptCommaAttachedMDList   << astx.NewGetElementPtrInst($2, $4, $5, $6, $7) >>
//    ;
//
//    Indices
//       : empty
//       | "," IndexList   << $1, nil >>
//    ;
GetElementPtrInst
	: "getelementptr" OptInbounds FirstClassType "," FirstClassType Value OptCommaAttachedMDList                 << astx.NewGetElementPtrInst($2, $4, $5, nil, $6) >>
	| "getelementptr" OptInbounds FirstClassType "," FirstClassType Value "," IndexList OptCommaAttachedMDList   << astx.NewGetElementPtrInst($2, $4, $5, $7, $8) >>
;

IndexList
	: Index                 << astx.NewValueList($0) >>
	| IndexList "," Index   << astx.AppendValue($0, $2) >>
;

Index
	: IntType Value   << astx.NewValue($0, $1) >>
;

// --- [ Conversion instructions ] ---------------------------------------------

// ~~~ [ trunc ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TruncInst
	: "trunc" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewTruncInst($1, $2, $4, $5) >>
;

// ~~~ [ zext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ZExtInst
	: "zext" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewZExtInst($1, $2, $4, $5) >>
;

// ~~~ [ sext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SExtInst
	: "sext" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewSExtInst($1, $2, $4, $5) >>
;

// ~~~ [ fptrunc ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPTruncInst
	: "fptrunc" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewFPTruncInst($1, $2, $4, $5) >>
;

// ~~~ [ fpext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPExtInst
	: "fpext" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewFPExtInst($1, $2, $4, $5) >>
;

// ~~~ [ fptoui ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPToUIInst
	: "fptoui" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewFPToUIInst($1, $2, $4, $5) >>
;

// ~~~ [ fptosi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPToSIInst
	: "fptosi" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewFPToSIInst($1, $2, $4, $5) >>
;

// ~~~ [ uitofp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UIToFPInst
	: "uitofp" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewUIToFPInst($1, $2, $4, $5) >>
;

// ~~~ [ sitofp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SIToFPInst
	: "sitofp" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewSIToFPInst($1, $2, $4, $5) >>
;

// ~~~ [ ptrtoint ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PtrToIntInst
	: "ptrtoint" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewPtrToIntInst($1, $2, $4, $5) >>
;

// ~~~ [ inttoptr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IntToPtrInst
	: "inttoptr" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewIntToPtrInst($1, $2, $4, $5) >>
;

// ~~~ [ bitcast ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

BitCastInst
	: "bitcast" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewBitCastInst($1, $2, $4, $5) >>
;

// ~~~ [ addrspacecast ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AddrSpaceCastInst
	: "addrspacecast" FirstClassType Value "to" FirstClassType OptCommaAttachedMDList   << astx.NewAddrSpaceCastInst($1, $2, $4, $5) >>
;

// --- [ Other instructions ] --------------------------------------------------

// ~~~ [ icmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ICmpInst
	: "icmp" IntPred FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewICmpInst($1, $2, $3, $5, $6) >>
;

IntPred
	: "eq"    << ast.IntEQ, nil >>
	| "ne"    << ast.IntNE, nil >>
	| "ugt"   << ast.IntUGT, nil >>
	| "uge"   << ast.IntUGE, nil >>
	| "ult"   << ast.IntULT, nil >>
	| "ule"   << ast.IntULE, nil >>
	| "sgt"   << ast.IntSGT, nil >>
	| "sge"   << ast.IntSGE, nil >>
	| "slt"   << ast.IntSLT, nil >>
	| "sle"   << ast.IntSLE, nil >>
;

// ~~~ [ fcmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FCmpInst
	: "fcmp" FastMathFlags FloatPred FirstClassType Value "," Value OptCommaAttachedMDList   << astx.NewFCmpInst($2, $3, $4, $6, $7) >>
;

FloatPred
	: "false"   << ast.FloatFalse, nil >>
	| "oeq"     << ast.FloatOEQ, nil >>
	| "ogt"     << ast.FloatOGT, nil >>
	| "oge"     << ast.FloatOGE, nil >>
	| "olt"     << ast.FloatOLT, nil >>
	| "ole"     << ast.FloatOLE, nil >>
	| "one"     << ast.FloatONE, nil >>
	| "ord"     << ast.FloatORD, nil >>
	| "ueq"     << ast.FloatUEQ, nil >>
	| "ugt"     << ast.FloatUGT, nil >>
	| "uge"     << ast.FloatUGE, nil >>
	| "ult"     << ast.FloatULT, nil >>
	| "ule"     << ast.FloatULE, nil >>
	| "une"     << ast.FloatUNE, nil >>
	| "uno"     << ast.FloatUNO, nil >>
	| "true"    << ast.FloatTrue, nil >>
;

// ~~~ [ phi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PhiInst
	: "phi" FirstClassType IncomingList OptCommaAttachedMDList   << astx.NewPhiInst($1, $2, $3) >>
;

IncomingList
	: Incoming                    << astx.NewIncomingList($0) >>
	| IncomingList "," Incoming   << astx.AppendIncoming($0, $2) >>
;

Incoming
	: "[" Value "," LocalIdent "]"   << astx.NewIncoming($1, $3) >>
;

// ~~~ [ select ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SelectInst
	: "select" FirstClassType Value "," FirstClassType Value "," FirstClassType Value OptCommaAttachedMDList   << astx.NewSelectInst($1, $2, $4, $5, $7, $8, $9) >>
;

// ~~~ [ call ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CallInst
	: OptTail "call" FastMathFlags OptCallConv ParamAttrs Type Value "(" Args ")" FuncAttrs OptCommaAttachedMDList   << astx.NewCallInst($3, $5, $6, $8, $11) >>
;

OptTail
	: empty
	| Tail
;

Tail
	: "tail"
	| "musttail"
	| "notail"
;

Args
	: empty
	| ArgList
;

ArgList
	: Arg               << astx.NewValueList($0) >>
	| ArgList "," Arg   << astx.AppendValue($0, $2) >>
;

Arg
	: FirstClassType ParamAttrs Value   << astx.NewValue($0, $2) >>
;

// ~~~ [ va_arg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VAArgInst
	: "va_arg" FirstClassType Value "," FirstClassType OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ landingpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LandingPadInst
	: "landingpad" FirstClassType ClauseList OptCommaAttachedMDList          << nil, nil >>
	| "landingpad" FirstClassType "cleanup" Clauses OptCommaAttachedMDList   << nil, nil >>
;

Clauses
	: empty
	| ClauseList
;

ClauseList
	: Clause
	| ClauseList Clause
;

Clause
	: "catch" FirstClassType Value
	| "filter" FirstClassType ArrayConst
;

// ~~~ [ catchpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CatchPadInst
	: "catchpad" "within" LocalIdent ArrayConst OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ cleanuppad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CleanupPadInst
	: "cleanuppad" "within" ExceptionParent ArrayConst OptCommaAttachedMDList   << nil, nil >>
;

ExceptionParent
	: "none"
	| LocalIdent
;

// === [ Terminators ] =========================================================

Terminator
	: RetTerm
	| BrTerm
	| CondBrTerm
	| SwitchTerm
	| IndirectBrTerm
	| InvokeTerm
	| ResumeTerm
	| CatchSwitchTerm
	| CatchRetTerm
	| CleanupRetTerm
	| UnreachableTerm
;

// ~~~ [ ret ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RetTerm
	: "ret" VoidType OptCommaAttachedMDList               << astx.NewRetTerm(nil, nil, $2) >>
	| "ret" FirstClassType Value OptCommaAttachedMDList   << astx.NewRetTerm($1, $2, $3) >>
;

// ~~~ [ br ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Unconditional branch terminator.
BrTerm
	: "br" LabelType LocalIdent OptCommaAttachedMDList  << astx.NewBrTerm($1, $2, $3) >>
;

// Conditional branch terminator.
CondBrTerm
	: "br" IntType Value "," LabelType LocalIdent "," LabelType LocalIdent OptCommaAttachedMDList  << astx.NewCondBrTerm($1, $2, $4, $5, $7, $8, $9) >>
;

// ~~~ [ switch ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SwitchTerm
	: "switch" IntType Value "," LabelType LocalIdent "[" Cases "]" OptCommaAttachedMDList   << astx.NewSwitchTerm($1, $2, $4, $5, $7, $9) >>
;

Cases
	: empty
	| CastList
;

CastList
	: Case            << astx.NewCaseList($0) >>
	| CastList Case   << astx.AppendCase($0, $1) >>
;

Case
	: IntType Value "," LabelType LocalIdent   << astx.NewCase($0, $1, $3, $4) >>
;

// ~~~ [ indirectbr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IndirectBrTerm
	: "indirectbr" FirstClassType Value "," "[" Labels "]" OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ invoke ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

InvokeTerm
	: "invoke" OptCallConv ParamAttrs Type Value "(" Args ")" FuncAttrs OptOperandBundle "to" LabelType LocalIdent "unwind" LabelType LocalIdent OptCommaAttachedMDList   << nil, nil >>
;

OptOperandBundle
	: empty
	| OperandBundle
;

OperandBundle
	: "[" TagValues "]"
;

TagValues
	: empty
	| TagValueList
;

TagValueList
	: TagValue
	| TagValueList "," TagValue
;

TagValue
	: string_lit "(" Values ")"
;

Values
	: empty
	| ValueList
;

ValueList
	: FirstClassType Value
	| ValueList "," FirstClassType Value
;

// ~~~ [ resume ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ResumeTerm
	: "resume" FirstClassType Value OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ catchswitch ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CatchSwitchTerm
	: "catchswitch" "within" ExceptionParent "[" Labels "]" "unwind" "to" "caller" OptCommaAttachedMDList          << nil, nil >>
	| "catchswitch" "within" ExceptionParent "[" Labels "]" "unwind" LabelType LocalIdent OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ catchret ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CatchRetTerm
	: "catchret" "from" Value "to" LabelType LocalIdent OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ cleanupret ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CleanupRetTerm
	: "cleanupret" "from" Value "unwind" "to" "caller" OptCommaAttachedMDList          << nil, nil >>
	| "cleanupret" "from" Value "unwind" LabelType LocalIdent OptCommaAttachedMDList   << nil, nil >>
;

// ~~~ [ unreachable ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UnreachableTerm
	: "unreachable" OptCommaAttachedMDList   << astx.NewUnreachableTerm($1) >>
;

// ### [ Helper productions ] ##################################################

OptLinkage
	: empty
	| Linkage
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#linkage
Linkage
	: "appending"
	| "available_externally"
	| "common"
	| "internal"
	| "linkonce"
	| "linkonce_odr"
	| "private"
	| "weak"
	| "weak_odr"
;

OptExternLinkage
	: empty
	| ExternLinkage
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#linkage
ExternLinkage
	: "extern_weak"
	| "external"
;

OptVisibility
	: empty
	| Visibility
;

// From spec of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#visibility-styles
Visibility
	: "default"
	| "hidden"
	| "protected"
;

OptDLLStorageClass
	: empty
	| DLLStorageClass
;

// From spec of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#dllstorageclass
DLLStorageClass
	: "dllimport"
	| "dllexport"
;

OptThreadLocal
	: empty
	| ThreadLocal
;

// From spec of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#thread-local-storage-models
ThreadLocal
	: "thread_local"
	| "thread_local" "(" TLSModel ")"
;

TLSModel
	: "localdynamic"
	| "initialexec"
	| "localexec"
;

OptUnnamedAddr
	: empty
	| UnnamedAddr
;

UnnamedAddr
	: "local_unnamed_addr"
	| "unnamed_addr"
;

OptSection
	: empty
	| Section
;

Section
	: "section" string_lit
;

OptComdat
	: empty
	| Comdat
;

Comdat
	: "comdat"
	| "comdat" "(" ComdatName ")"
;

OptAlign
	: empty
	| Align
;

Align
	: "align" IntLit
;

OptGC
	: empty
	| GC
;

GC
	: "gc" string_lit
;

OptPrefix
	: empty
	| Prefix
;

// ref: http://llvm.org/docs/LangRef.html#prefix-data
Prefix
	: "prefix" FirstClassType Constant
;

OptPrologue
	: empty
	| Prologue
;

// ref: http://llvm.org/docs/LangRef.html#prologue-data
Prologue
	: "prologue" FirstClassType Constant
;

OptPersonality
	: empty
	| Personality
;

// ref: http://llvm.org/docs/LangRef.html#personality-function
Personality
	: "personality" FirstClassType Constant
;

ParamAttrs
	: empty
	| ParamAttrList
;

ParamAttrList
	: ParamAttr
	| ParamAttrList ParamAttr
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#parameter-attributes
ParamAttr
	: string_lit
	| string_lit "=" string_lit
	| Align
	| "byval"
	| "dereferenceable" "(" IntLit ")"
	| "dereferenceable_or_null" "(" IntLit ")"
	| "inalloca"
	| "inreg"
	| "nest"
	| "noalias"
	| "nocapture"
	| "nonnull"
	| "readnone" // NOTE: accepted by lli but not part of spec in v4.0
	| "readonly" // NOTE: accepted by lli but not part of spec in v4.0
	| "returned"
	| "signext"
	| "sret"
	| "swifterror"
	| "swiftself"
	| "writeonly" // NOTE: accepted by lli but not part of spec in v4.0
	| "zeroext"
;

FuncAttrs
	: empty
	| FuncAttrList
;

FuncAttrList
	: FuncAttr
	| FuncAttrList FuncAttr
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#function-attributes
FuncAttr
	: string_lit
	| string_lit "=" string_lit
	| AttrGroupID
	| "alignstack" "=" IntLit // NOTE: only valid in attribute group definitions.
	| "alignstack" "(" IntLit ")"
	| "allocsize" "(" IntLit ")"
	| "allocsize" "(" IntLit "," IntLit ")"
	| "alwaysinline"
	| "argmemonly"
	| "builtin"
	| "cold"
	| "convergent"
	| "inaccessiblemem_or_argmemonly"
	| "inaccessiblememonly"
	| "inlinehint"
	| "jumptable"
	| "minsize"
	| "naked"
	| "nobuiltin"
	| "noduplicate"
	| "noimplicitfloat"
	| "noinline"
	| "nonlazybind"
	| "norecurse"
	| "noredzone"
	| "noreturn"
	| "nounwind"
	| "optnone"
	| "optsize"
	| "readnone"
	| "readonly"
	| "returns_twice"
	| "safestack"
	| "sanitize_address"
	| "sanitize_memory"
	| "sanitize_thread"
	| "ssp"
	| "sspreq"
	| "sspstrong"
	| "uwtable"
	| "writeonly"
;

Elems
	: empty
	| ElemList
;

ElemList
	: Elem                << astx.NewConstantList($0) >>
	| ElemList "," Elem   << astx.AppendConstant($0, $2) >>
;

Elem
	: FirstClassType Value   << astx.NewConstant($0, $1) >>
;

OptCallConv
	: empty      << ast.CallConvNone, nil >>
	| CallConv
;

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#callingconv
CallConv
	: "amdgpu_cs"          << ast.CallConvAMDGPU_CS, nil >>
	| "amdgpu_gs"          << ast.CallConvAMDGPU_GS, nil >>
	| "amdgpu_kernel"      << ast.CallConvAMDGPU_Kernel, nil >>
	| "amdgpu_ps"          << ast.CallConvAMDGPU_PS, nil >>
	| "amdgpu_vs"          << ast.CallConvAMDGPU_VS, nil >>
	| "anyregcc"           << ast.CallConvAnyReg, nil >>
	| "arm_aapcs_vfpcc"    << ast.CallConvARM_AAPCS_VFP, nil >>
	| "arm_aapcscc"        << ast.CallConvARM_AAPCS, nil >>
	| "arm_apcscc"         << ast.CallConvARM_APCS, nil >>
	| "avr_intrcc"         << ast.CallConvAVR_Intr, nil >>
	| "avr_signalcc"       << ast.CallConvAVR_Signal, nil >>
	| "cc" IntLit          << astx.NewCallConv($1) >>
	| "ccc"                << ast.CallConvC, nil >>
	| "coldcc"             << ast.CallConvCold, nil >>
	| "cxx_fast_tlscc"     << ast.CallConvCXX_Fast_TLS, nil >>
	| "fastcc"             << ast.CallConvFast, nil >>
	| "ghccc"              << ast.CallConvGHC, nil >>
	| "hhvm_ccc"           << ast.CallConvHHVM_C, nil >>
	| "hhvmcc"             << ast.CallConvHHVM, nil >>
	| "intel_ocl_bicc"     << ast.CallConvIntel_OCL_BI, nil >>
	| "msp430_intrcc"      << ast.CallConvMSP430_Intr, nil >>
	| "preserve_allcc"     << ast.CallConvPreserveAll, nil >>
	| "preserve_mostcc"    << ast.CallConvPreserveMost, nil >>
	| "ptx_device"         << ast.CallConvPTX_Device, nil >>
	| "ptx_kernel"         << ast.CallConvPTX_Kernel, nil >>
	| "spir_func"          << ast.CallConvSPIR_Func, nil >>
	| "spir_kernel"        << ast.CallConvSPIR_Kernel, nil >>
	| "swiftcc"            << ast.CallConvSwift, nil >>
	| "webkit_jscc"        << ast.CallConvWebKit_JS, nil >>
	| "x86_64_sysvcc"      << ast.CallConvX86_64_SysV, nil >>
	| "x86_64_win64cc"     << ast.CallConvX86_64_Win64, nil >>
	| "x86_fastcallcc"     << ast.CallConvX86_FastCall, nil >>
	| "x86_intrcc"         << ast.CallConvX86_Intr, nil >>
	| "x86_regcallcc"      << ast.CallConvX86_RegCall, nil >>
	| "x86_stdcallcc"      << ast.CallConvX86_StdCall, nil >>
	| "x86_thiscallcc"     << ast.CallConvX86_ThisCall, nil >>
	| "x86_vectorcallcc"   << ast.CallConvX86_VectorCall, nil >>
;

Labels
	: empty
	| LabelList
;

LabelList
	: Label
	| LabelList "," Label
;

Label
	: LabelType LocalIdent
;

OptInbounds
	: empty
	| "inbounds"
;

AttachedMDs
	: empty
	| AttachedMDList
;

AttachedMDList
	: AttachedMD                  << astx.NewAttachedMDList($0) >>
	| AttachedMDList AttachedMD   << astx.AppendAttachedMD($0, $1) >>
;

AttachedMD
	: MetadataName MD   << astx.NewAttachedMD($0, $1) >>
;

MD
	: Metadata
	| MetadataID
;

OptCommaAttachedMDList
	: empty
	| CommaAttachedMDList
;

CommaAttachedMDList
	: "," AttachedMD                       << astx.NewAttachedMDList($1) >>
	| CommaAttachedMDList "," AttachedMD   << astx.AppendAttachedMD($0, $2) >>
;